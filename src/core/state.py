"""
GraphState definition for the multi-agent financial analysis framework.

This module defines the central state object that flows through the entire workflow,
serving as the "working memory" of the system.
"""

from typing import List, Dict, Any, Literal, Optional
from pydantic import BaseModel, Field
from datetime import datetime


class TaskDefinition(BaseModel):
    """Definition of a single task in the execution plan."""
    task_id: str = Field(description="Unique identifier for the task")
    agent: str = Field(description="Name of the agent to execute this task") 
    tool: str = Field(description="Name of the tool to be used")
    inputs: Dict[str, Any] = Field(description="Input parameters for the tool")
    depends_on: Optional[str] = Field(None, description="Task ID this task depends on")
    status: Literal["pending", "running", "completed", "failed"] = Field(
        default="pending", description="Current status of the task"
    )


class ErrorRecord(BaseModel):
    """Structured error record for tracking failures."""
    task_id: str = Field(description="ID of the task that failed")
    agent: str = Field(description="Name of the agent that encountered the error")
    tool: str = Field(description="Name of the tool that failed")
    error_type: str = Field(description="Type of error (e.g., API_TIMEOUT, INVALID_INPUT)")
    error_message: str = Field(description="Detailed error message")
    timestamp: datetime = Field(default_factory=datetime.now)
    retry_count: int = Field(default=0, description="Number of times this task has been retried")


class GraphState(BaseModel):
    """
    Central state object that flows through the entire workflow graph.
    
    This serves as the "working memory" of the system, containing all context,
    data, instructions, and history records.
    """
    
    # Input and classification
    original_query: str = Field(description="User's original, unmodified query")
    query_complexity: Optional[Literal["SIMPLE", "COMPLEX", "OOS"]] = Field(
        None, description="Query complexity classification by the router"
    )
    
    # Task planning and execution
    task_plan: List[TaskDefinition] = Field(
        default_factory=list,
        description="Structured step-by-step task plan generated by the planner"
    )
    agent_results: Dict[str, Any] = Field(
        default_factory=dict,
        description="Results from successful agent/tool executions, keyed by task_id"
    )
    
    # Error handling
    error_log: List[ErrorRecord] = Field(
        default_factory=list,
        description="Structured log of errors encountered during execution"
    )
    
    # Output
    final_answer: str = Field(
        default="", 
        description="Final answer synthesized by the answer generation agent"
    )
    
    # Session tracking
    session_id: str = Field(description="Unique identifier for the entire interaction")
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    
    class Config:
        """Pydantic configuration."""
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
    
    def update_timestamp(self):
        """Update the last modified timestamp."""
        self.updated_at = datetime.now()
    
    def add_error(self, task_id: str, agent: str, tool: str, 
                  error_type: str, error_message: str, retry_count: int = 0):
        """Add an error record to the error log."""
        error_record = ErrorRecord(
            task_id=task_id,
            agent=agent,
            tool=tool,
            error_type=error_type,
            error_message=error_message,
            retry_count=retry_count
        )
        self.error_log.append(error_record)
        self.update_timestamp()
    
    def get_task_by_id(self, task_id: str) -> Optional[TaskDefinition]:
        """Get a task definition by its ID."""
        for task in self.task_plan:
            if task.task_id == task_id:
                return task
        return None
    
    def get_pending_tasks(self) -> List[TaskDefinition]:
        """Get all tasks that are still pending execution."""
        return [task for task in self.task_plan if task.status == "pending"]
    
    def mark_task_completed(self, task_id: str, result: Any):
        """Mark a task as completed and store its result."""
        task = self.get_task_by_id(task_id)
        if task:
            task.status = "completed"
            self.agent_results[task_id] = result
            self.update_timestamp()
    
    def mark_task_failed(self, task_id: str):
        """Mark a task as failed."""
        task = self.get_task_by_id(task_id)
        if task:
            task.status = "failed"
            self.update_timestamp()
    
    def has_critical_errors(self) -> bool:
        """Check if there are any critical errors that should stop execution."""
        critical_error_types = ["UNRECOVERABLE_ERROR", "AUTH_FAILURE"]
        return any(error.error_type in critical_error_types for error in self.error_log)